# How the runner works

ReSharper's unit test infrastructure walks a tree of tasks, generated by collapsing tasks
returned as lists for each unit test element from the various providers. Each task has a
runner ID, and the infrastructure maintains a map between runner ID, provider and that
provider's task runner. This class is the task runner returned by the xunit provider.

The test infrastructure creates an instance of ``StartupTaskRunnerHost``, and calls ``ExecuteNodes``.
This in turn walks the top-level tasks in the tree, gets the associated runner as an
instance of ``RecursiveRemoteTaskRunner`` and calls ``ExecuteRecursive``.

The built in providers set up top-level tasks of ``AssemblyLoadTask``, with a runner ID of
"AssemblyLoadTaskRunner" (and 7.1 supports NotIsolatedAssemblyLoadTask with a runner ID
of "NotIsolatedAssemblyLoadTaskRunner"). These runner IDs are special, and automatically
added by TaskRunnerHostBase, the base class of StartupTaskRunnerHost (and other hosts, see below).
By default, "AssemblyLoadTaskRunner" is mapped to IsolatedAssemblyTaskRunner, and
"NotIsolatedAssemblyLoadTaskRunner" is mapped to AssemblyLoadTaskRunner. Obviously.

So, StartupTaskRunnerHost walks the top-level tasks, sees the AssemblyLoadTask,
and calls IsolatedAssemblyTaskRunner.ExecuteRecursive. This in turn creates an instance of
IsolatedAppDomainHost, which then sets up shadow-copying, and creates a new AppDomain
containing the assembly from the AssemblyLoadTask and an instance of CurrentAppDomainHost.
IsolatedAssemblyTaskRunner then calls IsolatedAppDomainHost.ExecuteNodes, passing in the
children of the AssemblyLoadTask. This serialises the task nodes, passes them across the
AppDomain boundary and calls CurrentAppDomainHost.ExecuteNodes, which in turn walks the
new top-level tasks (the children of the AssemblyLoadTask) and passes these sub-trees to
the appropriate runners.

If CurrentAppDomainHost (in the new AppDomain) encounters another AssemblyLoadTask, that
task is now mapped to AssemblyLoadTaskRunner, which simply changes the current directory
to the codebase of the assembly in the task, and uses a new instance of CurrentAppDomainHost
to ExecuteNodes on the children of the AssemblyLoadTask. No new AppDomain is created.

For ReSharper 7.1, the mstest provider uses NotIsolatedAssemblyTaskRunner as its top-level
task. This uses AssemblyLoadTaskRunner to set the current directory (so the assembly codebase
works) and continues running the task nodes in the current AppDomain.

To make life a little more interesting, CurrentAppDomainHost (which *always* does the running)
queries IRemoteTaskServer.ClientControllerInfo, and if it returns anything, creates a new class
from the info. This is how dotCover hooks into the unit testing process. It then creates a new
wrapper for IRemoteTaskServer that calls this client controller on TaskStarting and TaskFinished,
and also notifies the client controller before the  whole run starts and when it finishes (7.1
adds an additional info call when things finish, because dotCover requested it, but now they
don't use it).

And we finally get to xunit. We want to let xunit handle creating the new AppDomain and dealing
with shadow copy and everything. So we don't use AssemblyLoadTask. Which means our entire
sub-tree of task nodes execute in the default AppDomain, in the context of StartupTaskRunnerHost,
and we never use CurrentAppDomainHost at all, and that means dotCover doesn't work. And both
CurrentAppDomainHost and the ClientControllerServerWrapper classes are internal. And we can't
use NotIsolatedAssemblyLoadTask because that's only 7.1, and for now, I still want to support 6.1

