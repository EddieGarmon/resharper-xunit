using JetBrains.ReSharper.TaskRunnerFramework;

namespace XunitContrib.Runner.ReSharper.RemoteRunner
{
    /// <summary>
    /// Entry point task runner for xunit tests
    /// </summary>
    #region The gritty details
    /// <remarks>
    /// <para>
    /// ReSharper's unit test infrastructure walks a tree of tasks, generated by collapsing tasks
    /// returned as lists for each unit test element from the various providers. Each task has a
    /// runner ID, and the infrastructre maintains a map between runner ID, provider and that
    /// provider's task runner. This class is the task runner returned by the xunit provider.
    /// </para>
    /// <para>
    /// The test infrastructure creates an instance of StartupTaskRunnerHost, and calls ExecuteNodes.
    /// This in turn walks the top-level tasks in the tree, gets the associated runner as an
    /// instance of RecursiveRemoteTaskRunner and calls ExecuteRecursive.
    /// </para>
    /// <para>
    /// The built in providers set up top-level tasks of AssemblyLoadTask, with a runner ID of
    /// "AssemblyLoadTaskRunner" (and 7.1 supports NotIsolatedAssemblyLoadTask with a runner ID
    /// of "NotIsolatedAssemblyLoadTaskRunner"). These runner IDs are special, and automatically
    /// added by TaskRunnerHostBase, the base class of StartupTaskRunnerHost (and other hosts, see below).
    /// By default, "AssemblyLoadTaskRunner" is mapped to IsolatedAssemblyTaskRunner, and
    /// "NotIsolatedAssemblyLoadTaskRunner" is mapped to AssemblyLoadTaskRunner. Obviously.
    /// </para>
    /// <para>
    /// So, StartupTaskRunnerHost walks the top-level tasks, sees the AssemblyLoadTask,
    /// and calls IsolatedAssemblyTaskRunner.ExecuteRecursive. This in turn creates an instance of
    /// IsolatedAppDomainHost, which then sets up shadow-copying, and creates a new AppDomain
    /// containing the assembly from the AssemblyLoadTask and an instance of CurrentAppDomainHost.
    /// IsolatedAssemblyTaskRunner then calls IsolatedAppDomainHost.ExecuteNodes, passing in the
    /// children of the AssemblyLoadTask. This serialises the task nodes, passes them across the
    /// AppDomain boundary and calls CurrentAppDomainHost.ExecuteNodes, which in turn walks the
    /// new top-level tasks (the children of the AssemblyLoadTask) and passes these sub-trees to
    /// the appropriate runners.
    /// </para>
    /// <para>
    /// If CurrentAppDomainHost (in the new AppDomain) encounters another AssemblyLoadTask, that
    /// task is now mapped to AssemblyLoadTaskRunner, which simply changes the current directory
    /// to the codebase of the assembly in the task, and uses a new instance of CurrentAppDomainHost
    /// to ExecuteNodes on the children of the AssemblyLoadTask. No new AppDomain is created.
    /// </para>
    /// <para>
    /// For ReSharper 7.1, the mstest provider uses NotIsolatedAssemblyTaskRunner as its top-level
    /// task. This uses AssemblyLoadTaskRunner to set the current directory (so the assembly codebase
    /// works) and continues running the task nodes in the current AppDomain.
    /// </para>
    /// <para>
    /// To make life a little more interesting, CurrentAppDomainHost (which *always* does the running)
    /// queries IRemoteTaskServer.ClientControllerInfo, and if it returns anything, creates a new class
    /// from the info. This is how dotCover hooks into the unit testing process. It then creates a new
    /// wrapper for IRemoteTaskServer that calls this client controller on TaskStarting and TaskFinished,
    /// and also notifies the client controller before the  whole run starts and when it finishes (7.1
    /// adds an additional info call when things finish, because dotCover requested it, but now they
    /// don't use it).
    /// </para>
    /// <para>
    /// And we finally get to xunit. We want to let xunit handle creating the new AppDomain and dealing
    /// with shadow copy and everything. So we don't use AssemblyLoadTask. Which means our entire
    /// sub-tree of task nodes execute in the default AppDomain, in the context of StartupTaskRunnerHost,
    /// and we never use CurrentAppDomainHost at all, and that means dotCover doesn't work. And both
    /// CurrentAppDomainHost and the ClientControllerServerWrapper classes are internal. And we can't
    /// use NotIsolatedAssemblyLoadTask because that's only 7.1, and for now, I still want to support 6.1
    /// </para>
    /// <para>
    /// So, this class handles the housekeeping for us, creating the client controller, creating the
    /// wrapper for the IRemoteTaskServer that calls the client controller correctly, and then
    /// defers to <see cref="TestRunner"/> to actually run the tests.
    /// </para>
    /// </remarks>
    #endregion
    public class XunitTaskRunner : RecursiveRemoteTaskRunnerBase
    {
        public const string RunnerId = "xUnit";

        private readonly ClientController clientController;
        private readonly TestRunner testRunner;

        public XunitTaskRunner(IRemoteTaskServer server)
            : base(server)
        {
            clientController = new ClientController(server);
            testRunner = new TestRunner(clientController.Server);
        }

        public override void ExecuteRecursive(TaskExecutionNode node)
        {
            clientController.BeforeExecuteRecursive();
            testRunner.ExecuteRecursive(node);
            clientController.AfterExecuteRecursive();
        }
    }
}